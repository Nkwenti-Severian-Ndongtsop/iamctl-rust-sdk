{"files":[{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","examples","basic_provider.rs"],"content":"use async_trait::async_trait;\nuse iamctl_rust_sdk::prelude::*;\n\nstruct MockProvider;\n\n#[async_trait]\nimpl Provider for MockProvider {\n    fn metadata(&self) -> ProviderMetadata {\n        ProviderMetadata {\n            name: \"mock-provider\".to_string(),\n            version: \"0.1.0\".to_string(),\n            author: Some(\"iamctl Team\".to_string()),\n            repository: Some(\n                \"https://github.com/Nkwenti-Severian-Ndongtsop/iamctl-rust-sdk\".to_string(),\n            ),\n            description: Some(\"A mock provider for testing the iamctl SDK\".to_string()),\n        }\n    }\n\n    fn capabilities(&self) -> ProviderCapabilities {\n        ProviderCapabilities {\n            supported_resources: vec![\"realm\".to_string(), \"client\".to_string()],\n            can_import: true,\n            can_validate: true,\n        }\n    }\n\n    async fn plan(&self, _request: PlanRequest) -> anyhow::Result<PlanResponse> {\n        Ok(PlanResponse { changes: vec![] })\n    }\n\n    async fn apply(&self, _request: ApplyRequest) -> anyhow::Result<ApplyResponse> {\n        Ok(ApplyResponse {\n            successful_addresses: vec![],\n            failed_addresses: vec![],\n        })\n    }\n}\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    iamctl_rust_sdk::utils::init_logging();\n\n    let provider = MockProvider;\n    println!(\n        \"Provider: {} (v{})\",\n        provider.metadata().name,\n        provider.metadata().version\n    );\n\n    // In a real implementation, we would start the JSON-RPC server here\n    // let server = JsonRpcServer::new(provider);\n    // server.serve().await?;\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","lib.rs"],"content":"#![deny(unused_crate_dependencies)]\n#![deny(unused_results)]\n#![deny(dead_code)]\n#![deny(unused_imports)]\n\n// Force usage of dependencies that are used in submodules or for features\nuse anyhow as _;\nuse chrono as _;\nuse futures as _;\nuse jsonschema as _;\nuse schemars as _;\nuse serde_yaml as _;\nuse tracing as _;\nuse uuid as _;\n\n#[cfg(test)]\nuse criterion as _;\n#[cfg(test)]\nuse insta as _;\n#[cfg(test)]\nuse mockall as _;\n#[cfg(test)]\nuse pretty_assertions as _;\n#[cfg(test)]\nuse proptest as _;\n#[cfg(test)]\nuse tempfile as _;\n#[cfg(test)]\nuse tokio_test as _;\n\npub mod provider;\npub mod server;\npub mod types;\npub mod utils;\npub mod validation;\n\npub mod prelude {\n    pub use crate::provider::{\n        ApplyRequest, ApplyResponse, PlanRequest, PlanResponse, Provider, ProviderCapabilities,\n        ProviderMetadata,\n    };\n    pub use crate::types::{Change, ChangeType, Resource, ResourceAddress};\n    pub use crate::validation::{SchemaValidator, ValidationError, ValidationResult};\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","provider","mod.rs"],"content":"use crate::types::{Change, Resource, ResourceAddress};\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProviderMetadata {\n    pub name: String,\n    pub version: String,\n    pub author: Option<String>,\n    pub repository: Option<String>,\n    pub description: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProviderCapabilities {\n    pub supported_resources: Vec<String>,\n    pub can_import: bool,\n    pub can_validate: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PlanRequest {\n    pub workspace_path: String,\n    pub desired_state: Vec<Resource>,\n    pub current_state: Vec<Resource>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PlanResponse {\n    pub changes: Vec<Change>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ApplyRequest {\n    pub changes: Vec<Change>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ApplyResponse {\n    pub successful_addresses: Vec<ResourceAddress>,\n    pub failed_addresses: Vec<(ResourceAddress, String)>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ValidateRequest {\n    pub resources: Vec<Resource>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ValidateResponse {\n    pub valid: bool,\n    pub errors: Vec<(ResourceAddress, String)>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ImportRequest {\n    pub address: ResourceAddress,\n    pub id: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ImportResponse {\n    pub resource: Resource,\n}\n\n#[async_trait]\npub trait Provider: Send + Sync {\n    fn metadata(&self) -> ProviderMetadata;\n    fn capabilities(&self) -> ProviderCapabilities;\n\n    async fn plan(&self, request: PlanRequest) -> anyhow::Result<PlanResponse>;\n    async fn apply(&self, request: ApplyRequest) -> anyhow::Result<ApplyResponse>;\n\n    async fn validate(&self, _request: ValidateRequest) -> anyhow::Result<ValidateResponse> {\n        Ok(ValidateResponse {\n            valid: true,\n            errors: vec![],\n        })\n    }\n\n    async fn import(&self, _request: ImportRequest) -> anyhow::Result<ImportResponse> {\n        Err(anyhow::anyhow!(\"Import not implemented\"))\n    }\n}\n","traces":[{"line":74,"address":[2909729,2909634,2910092,2909533,2909954,2909887,2909504,2909702],"length":1,"stats":{"Line":0}},{"line":75,"address":[2909983],"length":1,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[2909942],"length":1,"stats":{"Line":0}},{"line":81,"address":[2910404,2910531,2910291,2910812,2910666,2910190,2910160,2910380],"length":1,"stats":{"Line":0}},{"line":82,"address":[2910632,2910706],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","server","client.rs"],"content":"use crate::server::types::{JsonRpcRequest, JsonRpcResponse};\nuse crate::utils::Result;\nuse serde::de::DeserializeOwned;\nuse serde::Serialize;\nuse std::process::Stdio;\nuse tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};\nuse tokio::process::{Child, ChildStdout, Command};\n\n/// A JSON-RPC client for communicating with a provider process.\n/// Useful for testing and for the engine to call providers.\npub struct JsonRpcClient {\n    child: Child,\n    stdout_reader: BufReader<ChildStdout>,\n}\n\nimpl JsonRpcClient {\n    /// Launches a provider executable and initializes the client.\n    pub fn launch(executable_path: &str) -> Result<Self> {\n        let mut child = Command::new(executable_path)\n            .stdin(Stdio::piped())\n            .stdout(Stdio::piped())\n            .spawn()?;\n\n        let stdout = child.stdout.take().ok_or_else(|| {\n            crate::utils::Error::Internal(\n                \"Failed to capture stdout of provider process\".to_string(),\n            )\n        })?;\n\n        Ok(Self {\n            child,\n            stdout_reader: BufReader::new(stdout),\n        })\n    }\n\n    /// Calls a method on the provider and returns the result.\n    pub async fn call<P, R>(&mut self, method: &str, params: P) -> Result<R>\n    where\n        P: Serialize,\n        R: DeserializeOwned,\n    {\n        let id = serde_json::Value::Number(1.into());\n        let request = JsonRpcRequest {\n            jsonrpc: \"2.0\".to_string(),\n            method: method.to_string(),\n            params: serde_json::to_value(params)?,\n            id: Some(id),\n        };\n\n        let mut json = serde_json::to_string(&request)?;\n        json.push('\\n');\n\n        let stdin = self.child.stdin.as_mut().ok_or_else(|| {\n            crate::utils::Error::Internal(\"Failed to access provider stdin\".to_string())\n        })?;\n\n        stdin.write_all(json.as_bytes()).await?;\n        stdin.flush().await?;\n\n        let mut response_line = String::new();\n        let _ = self.stdout_reader.read_line(&mut response_line).await?;\n\n        let response: JsonRpcResponse = serde_json::from_str(&response_line)?;\n\n        if let Some(error) = response.error {\n            return Err(crate::utils::Error::Protocol(format!(\n                \"JSON-RPC Error {}: {}\",\n                error.code, error.message\n            )));\n        }\n\n        let result = response.result.ok_or_else(|| {\n            crate::utils::Error::Protocol(\"Missing result in JSON-RPC response\".to_string())\n        })?;\n\n        Ok(serde_json::from_value(result)?)\n    }\n}\n","traces":[{"line":18,"address":[2990693,2989648,2990622],"length":1,"stats":{"Line":0}},{"line":19,"address":[2989933,2989785,2989825,2989681],"length":1,"stats":{"Line":0}},{"line":20,"address":[2989710],"length":1,"stats":{"Line":0}},{"line":21,"address":[2989797],"length":1,"stats":{"Line":0}},{"line":24,"address":[2990083,2990275],"length":1,"stats":{"Line":0}},{"line":25,"address":[3072863],"length":1,"stats":{"Line":0}},{"line":26,"address":[3072830],"length":1,"stats":{"Line":0}},{"line":30,"address":[2990514],"length":1,"stats":{"Line":0}},{"line":31,"address":[2990372],"length":1,"stats":{"Line":0}},{"line":32,"address":[2990407],"length":1,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":31},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","server","handler.rs"],"content":"use crate::provider::{ApplyRequest, ImportRequest, PlanRequest, Provider, ValidateRequest};\nuse crate::server::types::{JsonRpcRequest, JsonRpcResponse};\nuse std::sync::Arc;\n\n/// Handles the routing and processing of JSON-RPC requests to the provider.\npub struct RequestHandler<P: Provider> {\n    provider: Arc<P>,\n}\n\nimpl<P: Provider + 'static> RequestHandler<P> {\n    pub fn new(provider: Arc<P>) -> Self {\n        Self { provider }\n    }\n\n    pub async fn handle(&self, request: JsonRpcRequest) -> JsonRpcResponse {\n        let id = request.id.clone().unwrap_or(serde_json::Value::Null);\n\n        match request.method.as_str() {\n            \"metadata\" => self.handle_metadata(id).await,\n            \"capabilities\" => self.handle_capabilities(id).await,\n            \"plan\" => self.handle_plan(id, request.params).await,\n            \"apply\" => self.handle_apply(id, request.params).await,\n            \"validate\" => self.handle_validate(id, request.params).await,\n            \"import\" => self.handle_import(id, request.params).await,\n            _ => {\n                JsonRpcResponse::error(id, -32601, format!(\"Method not found: {}\", request.method))\n            }\n        }\n    }\n\n    async fn handle_metadata(&self, id: serde_json::Value) -> JsonRpcResponse {\n        let metadata = self.provider.metadata();\n        match serde_json::to_value(metadata) {\n            Ok(val) => JsonRpcResponse::success(id, val),\n            Err(e) => JsonRpcResponse::error(id, -32603, format!(\"Internal error: {e}\")),\n        }\n    }\n\n    async fn handle_capabilities(&self, id: serde_json::Value) -> JsonRpcResponse {\n        let capabilities = self.provider.capabilities();\n        match serde_json::to_value(capabilities) {\n            Ok(val) => JsonRpcResponse::success(id, val),\n            Err(e) => JsonRpcResponse::error(id, -32603, format!(\"Internal error: {e}\")),\n        }\n    }\n\n    async fn handle_plan(\n        &self,\n        id: serde_json::Value,\n        params: serde_json::Value,\n    ) -> JsonRpcResponse {\n        let request: PlanRequest = match serde_json::from_value(params) {\n            Ok(req) => req,\n            Err(e) => return JsonRpcResponse::error(id, -32602, format!(\"Invalid params: {e}\")),\n        };\n\n        match self.provider.plan(request).await {\n            Ok(resp) => match serde_json::to_value(resp) {\n                Ok(val) => JsonRpcResponse::success(id, val),\n                Err(e) => JsonRpcResponse::error(id, -32603, format!(\"Internal error: {e}\")),\n            },\n            Err(e) => JsonRpcResponse::error(id, -32000, format!(\"Provider error: {e}\")),\n        }\n    }\n\n    async fn handle_apply(\n        &self,\n        id: serde_json::Value,\n        params: serde_json::Value,\n    ) -> JsonRpcResponse {\n        let request: ApplyRequest = match serde_json::from_value(params) {\n            Ok(req) => req,\n            Err(e) => return JsonRpcResponse::error(id, -32602, format!(\"Invalid params: {e}\")),\n        };\n\n        match self.provider.apply(request).await {\n            Ok(resp) => match serde_json::to_value(resp) {\n                Ok(val) => JsonRpcResponse::success(id, val),\n                Err(e) => JsonRpcResponse::error(id, -32603, format!(\"Internal error: {e}\")),\n            },\n            Err(e) => JsonRpcResponse::error(id, -32000, format!(\"Provider error: {e}\")),\n        }\n    }\n\n    async fn handle_validate(\n        &self,\n        id: serde_json::Value,\n        params: serde_json::Value,\n    ) -> JsonRpcResponse {\n        let request: ValidateRequest = match serde_json::from_value(params) {\n            Ok(req) => req,\n            Err(e) => return JsonRpcResponse::error(id, -32602, format!(\"Invalid params: {e}\")),\n        };\n\n        match self.provider.validate(request).await {\n            Ok(resp) => match serde_json::to_value(resp) {\n                Ok(val) => JsonRpcResponse::success(id, val),\n                Err(e) => JsonRpcResponse::error(id, -32603, format!(\"Internal error: {e}\")),\n            },\n            Err(e) => JsonRpcResponse::error(id, -32000, format!(\"Provider error: {e}\")),\n        }\n    }\n\n    async fn handle_import(\n        &self,\n        id: serde_json::Value,\n        params: serde_json::Value,\n    ) -> JsonRpcResponse {\n        let request: ImportRequest = match serde_json::from_value(params) {\n            Ok(req) => req,\n            Err(e) => return JsonRpcResponse::error(id, -32602, format!(\"Invalid params: {e}\")),\n        };\n\n        match self.provider.import(request).await {\n            Ok(resp) => match serde_json::to_value(resp) {\n                Ok(val) => JsonRpcResponse::success(id, val),\n                Err(e) => JsonRpcResponse::error(id, -32603, format!(\"Internal error: {e}\")),\n            },\n            Err(e) => JsonRpcResponse::error(id, -32000, format!(\"Provider error: {e}\")),\n        }\n    }\n}\n","traces":[{"line":11,"address":[2840592],"length":1,"stats":{"Line":2}},{"line":15,"address":[2845231,2841019,2840688,2840608,2840643,2843361,2840747,2842798],"length":1,"stats":{"Line":8}},{"line":16,"address":[2840982,2841209],"length":1,"stats":{"Line":4}},{"line":18,"address":[2841263,2841365],"length":1,"stats":{"Line":4}},{"line":19,"address":[2843265,2843387,2841476,2841387,2841049],"length":1,"stats":{"Line":4}},{"line":20,"address":[2841612,2843667,2841442,2841070,2841556,2843176],"length":1,"stats":{"Line":2}},{"line":21,"address":[2841692,2841751,2841091,2843929,2843087,2841578],"length":1,"stats":{"Line":2}},{"line":22,"address":[2844191,2841892,2841951,2841112,2841714,2842998],"length":1,"stats":{"Line":2}},{"line":23,"address":[2842092,2844453,2842909,2841133,2841914,2842151],"length":1,"stats":{"Line":2}},{"line":24,"address":[2841154,2842820,2842114,2844715,2842292,2842398],"length":1,"stats":{"Line":2}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[2842532,2842766,2842298],"length":1,"stats":{"Line":1}},{"line":31,"address":[2845528,2845598,2846334,2846386,2845520,2845707,2846348,2845568],"length":1,"stats":{"Line":4}},{"line":32,"address":[2845695,2845780],"length":1,"stats":{"Line":2}},{"line":33,"address":[2845800],"length":1,"stats":{"Line":1}},{"line":34,"address":[2845918],"length":1,"stats":{"Line":1}},{"line":35,"address":[2846070,2845834],"length":1,"stats":{"Line":0}},{"line":39,"address":[2846424,2846464,2847218,2847232,2846416,2846494,2847270,2846603],"length":1,"stats":{"Line":0}},{"line":40,"address":[2846676,2846591],"length":1,"stats":{"Line":0}},{"line":41,"address":[2846693],"length":1,"stats":{"Line":0}},{"line":42,"address":[2846805],"length":1,"stats":{"Line":0}},{"line":43,"address":[2846724,2846954],"length":1,"stats":{"Line":0}},{"line":47,"address":[2847296],"length":1,"stats":{"Line":0}},{"line":52,"address":[2847671,2847589],"length":1,"stats":{"Line":0}},{"line":53,"address":[2847800],"length":1,"stats":{"Line":0}},{"line":54,"address":[2847708,2848263,2848537],"length":1,"stats":{"Line":0}},{"line":57,"address":[2847623,2847968,2848026,2848840,2848612],"length":1,"stats":{"Line":0}},{"line":58,"address":[2848964,2849054],"length":1,"stats":{"Line":0}},{"line":59,"address":[2849168],"length":1,"stats":{"Line":0}},{"line":60,"address":[2849292,2849081],"length":1,"stats":{"Line":0}},{"line":62,"address":[2849556,2848877],"length":1,"stats":{"Line":0}},{"line":66,"address":[2849872],"length":1,"stats":{"Line":0}},{"line":71,"address":[2850165,2850247],"length":1,"stats":{"Line":0}},{"line":72,"address":[2850376],"length":1,"stats":{"Line":0}},{"line":73,"address":[2850969,2850284,2850695],"length":1,"stats":{"Line":0}},{"line":76,"address":[2851288,2850506,2850448,2851044,2850199],"length":1,"stats":{"Line":0}},{"line":77,"address":[2851518,2851412],"length":1,"stats":{"Line":0}},{"line":78,"address":[2851632],"length":1,"stats":{"Line":0}},{"line":79,"address":[2851545,2851756],"length":1,"stats":{"Line":0}},{"line":81,"address":[2852020,2851325],"length":1,"stats":{"Line":0}},{"line":85,"address":[2852336],"length":1,"stats":{"Line":0}},{"line":90,"address":[2852711,2852629],"length":1,"stats":{"Line":0}},{"line":91,"address":[2852840],"length":1,"stats":{"Line":0}},{"line":92,"address":[2853433,2853159,2852748],"length":1,"stats":{"Line":0}},{"line":95,"address":[2997874],"length":1,"stats":{"Line":0}},{"line":96,"address":[2853860,2853950],"length":1,"stats":{"Line":0}},{"line":97,"address":[2854064],"length":1,"stats":{"Line":0}},{"line":98,"address":[2854188,2853977],"length":1,"stats":{"Line":0}},{"line":100,"address":[2853773,2854452],"length":1,"stats":{"Line":0}},{"line":104,"address":[2854768],"length":1,"stats":{"Line":0}},{"line":109,"address":[2855064,2855146],"length":1,"stats":{"Line":0}},{"line":110,"address":[2855275],"length":1,"stats":{"Line":0}},{"line":111,"address":[2855183,2856061,2855787],"length":1,"stats":{"Line":0}},{"line":114,"address":[2855533,2856363,2856136,2855098,2855475],"length":1,"stats":{"Line":0}},{"line":115,"address":[2856577,2856520],"length":1,"stats":{"Line":0}},{"line":116,"address":[2856691],"length":1,"stats":{"Line":0}},{"line":117,"address":[2856604,2856815],"length":1,"stats":{"Line":0}},{"line":119,"address":[2857079,2856400],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":58},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","server","handler_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::prelude::*;\n    use crate::server::{JsonRpcRequest, RequestHandler};\n    use async_trait::async_trait;\n    use serde_json::json;\n    use std::sync::Arc;\n\n    struct TestProvider;\n\n    #[async_trait]\n    impl Provider for TestProvider {\n        fn metadata(&self) -> ProviderMetadata {\n            ProviderMetadata {\n                name: \"test-provider\".to_string(),\n                version: \"1.0.0\".to_string(),\n                author: None,\n                repository: None,\n                description: None,\n            }\n        }\n\n        fn capabilities(&self) -> ProviderCapabilities {\n            ProviderCapabilities {\n                supported_resources: vec![\"realm\".to_string()],\n                can_import: false,\n                can_validate: false,\n            }\n        }\n\n        async fn plan(&self, _request: PlanRequest) -> anyhow::Result<PlanResponse> {\n            Ok(PlanResponse { changes: vec![] })\n        }\n\n        async fn apply(&self, _request: ApplyRequest) -> anyhow::Result<ApplyResponse> {\n            Ok(ApplyResponse {\n                successful_addresses: vec![],\n                failed_addresses: vec![],\n            })\n        }\n    }\n\n    #[tokio::test]\n    async fn test_handle_metadata() {\n        let provider = Arc::new(TestProvider);\n        let handler = RequestHandler::new(provider);\n        let request = JsonRpcRequest {\n            jsonrpc: \"2.0\".to_string(),\n            method: \"metadata\".to_string(),\n            params: json!({}),\n            id: Some(json!(1)),\n        };\n\n        let response = handler.handle(request).await;\n        assert_eq!(response.id, json!(1));\n        assert!(response.error.is_none());\n        let result = response.result.unwrap();\n        assert_eq!(result[\"name\"], \"test-provider\");\n    }\n\n    #[tokio::test]\n    async fn test_method_not_found() {\n        let provider = Arc::new(TestProvider);\n        let handler = RequestHandler::new(provider);\n        let request = JsonRpcRequest {\n            jsonrpc: \"2.0\".to_string(),\n            method: \"non_existent\".to_string(),\n            params: json!({}),\n            id: Some(json!(1)),\n        };\n\n        let response = handler.handle(request).await;\n        assert_eq!(response.id, json!(1));\n        assert!(response.result.is_none());\n        assert_eq!(response.error.unwrap().code, -32601);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","server","mod.rs"],"content":"pub mod client;\npub mod handler;\npub mod types;\n\n#[cfg(test)]\nmod handler_tests;\n\npub use client::JsonRpcClient;\npub use handler::RequestHandler;\npub use types::{JsonRpcError, JsonRpcRequest, JsonRpcResponse};\n\nuse crate::provider::Provider;\nuse std::sync::Arc;\nuse tokio::io::{self, AsyncBufReadExt, AsyncWriteExt, BufReader};\n\n/// JSON-RPC Server that handles communication with the iamctl engine.\npub struct JsonRpcServer<P: Provider> {\n    handler: RequestHandler<P>,\n}\n\nimpl<P: Provider + 'static> JsonRpcServer<P> {\n    /// Creates a new JSON-RPC server with the given provider.\n    pub fn new(provider: P) -> Self {\n        Self {\n            handler: RequestHandler::new(Arc::new(provider)),\n        }\n    }\n\n    /// Starts the server and listens for requests on stdin.\n    pub async fn serve(&self) -> crate::utils::Result<()> {\n        let stdin = io::stdin();\n        let mut reader = BufReader::new(stdin).lines();\n        let mut stdout = io::stdout();\n\n        while let Some(line) = reader.next_line().await? {\n            let request: JsonRpcRequest = match serde_json::from_str(&line) {\n                Ok(req) => req,\n                Err(e) => {\n                    let err_resp = JsonRpcResponse::error(\n                        serde_json::Value::Null,\n                        -32700,\n                        format!(\"Parse error: {e}\"),\n                    );\n                    self.send_response(&mut stdout, err_resp).await?;\n                    continue;\n                }\n            };\n\n            let response = self.handler.handle(request).await;\n            self.send_response(&mut stdout, response).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn send_response(\n        &self,\n        stdout: &mut io::Stdout,\n        response: JsonRpcResponse,\n    ) -> crate::utils::Result<()> {\n        let mut json = serde_json::to_string(&response)?;\n        json.push('\\n');\n        stdout.write_all(json.as_bytes()).await?;\n        stdout.flush().await?;\n        Ok(())\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":23},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","server","types.rs"],"content":"use serde::{Deserialize, Serialize};\n\n/// JSON-RPC 2.0 Request object\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcRequest {\n    pub jsonrpc: String,\n    pub method: String,\n    pub params: serde_json::Value,\n    pub id: Option<serde_json::Value>,\n}\n\n/// JSON-RPC 2.0 Response object\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcResponse {\n    pub jsonrpc: String,\n    pub result: Option<serde_json::Value>,\n    pub error: Option<JsonRpcError>,\n    pub id: serde_json::Value,\n}\n\n/// JSON-RPC 2.0 Error object\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcError {\n    pub code: i32,\n    pub message: String,\n    pub data: Option<serde_json::Value>,\n}\n\nimpl JsonRpcResponse {\n    pub fn success(id: serde_json::Value, result: serde_json::Value) -> Self {\n        Self {\n            jsonrpc: \"2.0\".to_string(),\n            result: Some(result),\n            error: None,\n            id,\n        }\n    }\n\n    pub fn error(id: serde_json::Value, code: i32, message: String) -> Self {\n        Self {\n            jsonrpc: \"2.0\".to_string(),\n            result: None,\n            error: Some(JsonRpcError {\n                code,\n                message,\n                data: None,\n            }),\n            id,\n        }\n    }\n}\n","traces":[{"line":30,"address":[2864129,2864151,2863728],"length":1,"stats":{"Line":1}},{"line":32,"address":[2863754],"length":1,"stats":{"Line":1}},{"line":33,"address":[2863836],"length":1,"stats":{"Line":1}},{"line":39,"address":[2864695,2864176,2864717],"length":1,"stats":{"Line":1}},{"line":41,"address":[2864214],"length":1,"stats":{"Line":1}},{"line":43,"address":[2864340],"length":1,"stats":{"Line":1}}],"covered":6,"coverable":6},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","types","mod.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt;\n\n/// Represents a stable address for a resource in the workspace.\n/// Address format: type.name (e.g., realm.demo, client.demo/my-app)\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct ResourceAddress {\n    pub resource_type: String,\n    pub name: String,\n    pub namespace: Option<String>,\n}\n\nimpl fmt::Display for ResourceAddress {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(ref ns) = self.namespace {\n            write!(f, \"{}.{}/{}\", self.resource_type, ns, self.name)\n        } else {\n            write!(f, \"{}.{}\", self.resource_type, self.name)\n        }\n    }\n}\n\n/// Represents the desired state of a resource as defined in configuration.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Resource {\n    pub address: ResourceAddress,\n    pub spec: HashMap<String, serde_json::Value>,\n    #[serde(default)]\n    pub metadata: HashMap<String, String>,\n}\n\n/// Represents a requested change to a resource.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub enum ChangeType {\n    Create,\n    Update,\n    Delete,\n    NoOp,\n}\n\n/// Represents the calculated diff between desired and current state.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Change {\n    pub address: ResourceAddress,\n    pub change_type: ChangeType,\n    pub before: Option<Resource>,\n    pub after: Option<Resource>,\n    #[serde(default)]\n    pub computed_fields: Vec<String>,\n}\n","traces":[{"line":15,"address":[2882304],"length":1,"stats":{"Line":0}},{"line":16,"address":[2882337],"length":1,"stats":{"Line":0}},{"line":17,"address":[2882391],"length":1,"stats":{"Line":0}},{"line":19,"address":[2882582],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","utils","error.rs"],"content":"use crate::types::ResourceAddress;\nuse thiserror::Error;\n\n/// Core error type for the IAMCTL SDK and providers.\n#[derive(Debug, Error)]\npub enum Error {\n    #[error(\"Provider error: {0}\")]\n    Provider(String),\n\n    #[error(\"Resource not found: {0}\")]\n    ResourceNotFound(ResourceAddress),\n\n    #[error(\"Validation failed: {0}\")]\n    Validation(String),\n\n    #[error(\"Protocol error: {0}\")]\n    Protocol(String),\n\n    #[error(\"Authentication failed: {0}\")]\n    Authentication(String),\n\n    #[error(\"Permission denied: {0}\")]\n    PermissionDenied(String),\n\n    #[error(\"Configuration error: {0}\")]\n    Config(String),\n\n    #[error(\"Internal error: {0}\")]\n    Internal(String),\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"Serialization error: {0}\")]\n    Serialization(#[from] serde_json::Error),\n\n    #[error(\"Task joined error: {0}\")]\n    Join(#[from] tokio::task::JoinError),\n\n    #[error(transparent)]\n    Other(#[from] anyhow::Error),\n}\n\n/// A specialized Result type for IAMCTL operations.\npub type Result<T> = std::result::Result<T, Error>;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","utils","logging.rs"],"content":"use tracing_subscriber::{fmt, prelude::*, EnvFilter};\n\n/// Initializes the logging system with default settings.\n/// By default, it uses the environment variable `RUST_LOG` to determine the log level.\npub fn init_logging() {\n    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(\"info\"));\n\n    tracing_subscriber::registry()\n        .with(fmt::layer())\n        .with(filter)\n        .init();\n}\n","traces":[{"line":5,"address":[2911336,2911342,2910944],"length":1,"stats":{"Line":0}},{"line":6,"address":[2887232,2887216],"length":1,"stats":{"Line":0}},{"line":8,"address":[2911049,2911170,2911276],"length":1,"stats":{"Line":0}},{"line":9,"address":[2911314,2911209,2911132,2911109],"length":1,"stats":{"Line":0}},{"line":10,"address":[2911217],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","utils","mod.rs"],"content":"pub mod error;\npub mod logging;\n\npub use error::{Error, Result};\npub use logging::init_logging;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","nkwentiseverian","my-projects","iamctl-rust-sdk","src","validation","mod.rs"],"content":"use crate::types::Resource;\nuse crate::utils::Result;\nuse serde_json::Value;\nuse std::collections::HashMap;\n\n/// Validation error details\n#[derive(Debug, Clone)]\npub struct ValidationError {\n    pub path: String,\n    pub message: String,\n    pub code: String,\n}\n\nimpl ValidationError {\n    pub fn new(path: &str, message: &str, code: &str) -> Self {\n        Self {\n            path: path.to_string(),\n            message: message.to_string(),\n            code: code.to_string(),\n        }\n    }\n}\n\n/// Validation result containing errors and warnings\n#[derive(Debug, Clone)]\npub struct ValidationResult {\n    pub valid: bool,\n    pub errors: Vec<ValidationError>,\n    pub warnings: Vec<ValidationError>,\n}\n\nimpl ValidationResult {\n    pub fn valid() -> Self {\n        Self {\n            valid: true,\n            errors: vec![],\n            warnings: vec![],\n        }\n    }\n\n    pub fn invalid(errors: Vec<ValidationError>) -> Self {\n        Self {\n            valid: false,\n            errors,\n            warnings: vec![],\n        }\n    }\n\n    pub fn with_warnings(mut self, warnings: Vec<ValidationError>) -> Self {\n        self.warnings = warnings;\n        self\n    }\n}\n\n/// Schema validator for resource specifications\npub trait SchemaValidator: Send + Sync {\n    fn validate(&self, resource: &Resource) -> Result<ValidationResult>;\n}\n\n/// JSON Schema validator implementation\npub struct JsonSchemaValidator {\n    schemas: HashMap<String, Value>,\n}\n\nimpl Default for JsonSchemaValidator {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl JsonSchemaValidator {\n    pub fn new() -> Self {\n        Self {\n            schemas: HashMap::new(),\n        }\n    }\n\n    pub fn add_schema(&mut self, resource_type: &str, schema: Value) {\n        let _ = self.schemas.insert(resource_type.to_string(), schema);\n    }\n\n    fn validate_against_schema(&self, resource: &Resource) -> Result<ValidationResult> {\n        let schema = match self.schemas.get(&resource.address.resource_type) {\n            Some(schema) => schema,\n            None => {\n                return Ok(ValidationResult::invalid(vec![ValidationError::new(\n                    \"\",\n                    &format!(\n                        \"No schema found for resource type: {}\",\n                        resource.address.resource_type\n                    ),\n                    \"SCHEMA_NOT_FOUND\",\n                )]));\n            }\n        };\n\n        // Basic validation logic - this will be expanded in later tasks\n        self.validate_basic_constraints(resource, schema)\n    }\n\n    fn validate_basic_constraints(\n        &self,\n        resource: &Resource,\n        _schema: &Value,\n    ) -> Result<ValidationResult> {\n        let mut errors = vec![];\n\n        // Check if spec has required fields\n        if resource.spec.is_empty() {\n            errors.push(ValidationError::new(\n                \"spec\",\n                \"Resource specification cannot be empty\",\n                \"EMPTY_SPEC\",\n            ));\n        }\n\n        // Check for invalid field names (basic example)\n        for key in resource.spec.keys() {\n            if key.starts_with('_') {\n                errors.push(ValidationError::new(\n                    &format!(\"spec.{key}\"),\n                    \"Field names cannot start with underscore\",\n                    \"INVALID_FIELD_NAME\",\n                ));\n            }\n        }\n\n        if errors.is_empty() {\n            Ok(ValidationResult::valid())\n        } else {\n            Ok(ValidationResult::invalid(errors))\n        }\n    }\n}\n\nimpl SchemaValidator for JsonSchemaValidator {\n    fn validate(&self, resource: &Resource) -> Result<ValidationResult> {\n        self.validate_against_schema(resource)\n    }\n}\n\n/// Composite validator that runs multiple validators\npub struct CompositeValidator {\n    validators: Vec<Box<dyn SchemaValidator>>,\n}\n\nimpl Default for CompositeValidator {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl CompositeValidator {\n    pub fn new() -> Self {\n        Self { validators: vec![] }\n    }\n\n    pub fn add_validator(mut self, validator: Box<dyn SchemaValidator>) -> Self {\n        self.validators.push(validator);\n        self\n    }\n}\n\nimpl SchemaValidator for CompositeValidator {\n    fn validate(&self, resource: &Resource) -> Result<ValidationResult> {\n        let mut all_errors = vec![];\n        let mut all_warnings = vec![];\n        let mut valid = true;\n\n        for validator in &self.validators {\n            let result = validator.validate(resource)?;\n            if !result.valid {\n                valid = false;\n            }\n            all_errors.extend(result.errors);\n            all_warnings.extend(result.warnings);\n        }\n\n        Ok(ValidationResult {\n            valid,\n            errors: all_errors,\n            warnings: all_warnings,\n        })\n    }\n}\n","traces":[{"line":15,"address":[3094048,3094396,3094390],"length":1,"stats":{"Line":0}},{"line":17,"address":[3094141],"length":1,"stats":{"Line":0}},{"line":18,"address":[3094180],"length":1,"stats":{"Line":0}},{"line":19,"address":[3094235],"length":1,"stats":{"Line":0}},{"line":33,"address":[3094416,3094552,3094558],"length":1,"stats":{"Line":0}},{"line":36,"address":[3094435],"length":1,"stats":{"Line":0}},{"line":37,"address":[3094445],"length":1,"stats":{"Line":0}},{"line":41,"address":[3094576,3094717],"length":1,"stats":{"Line":0}},{"line":45,"address":[3094611],"length":1,"stats":{"Line":0}},{"line":49,"address":[3094736,3094885],"length":1,"stats":{"Line":0}},{"line":50,"address":[3094768,3094842],"length":1,"stats":{"Line":0}},{"line":51,"address":[3094865],"length":1,"stats":{"Line":0}},{"line":66,"address":[3094912],"length":1,"stats":{"Line":0}},{"line":67,"address":[3094920],"length":1,"stats":{"Line":0}},{"line":72,"address":[3094944],"length":1,"stats":{"Line":0}},{"line":74,"address":[3094958],"length":1,"stats":{"Line":0}},{"line":78,"address":[3095213,3095008,3095184],"length":1,"stats":{"Line":0}},{"line":79,"address":[3095116,3095049],"length":1,"stats":{"Line":0}},{"line":82,"address":[3095984,3095973,3095232],"length":1,"stats":{"Line":0}},{"line":83,"address":[3095291],"length":1,"stats":{"Line":0}},{"line":84,"address":[3095344],"length":1,"stats":{"Line":0}},{"line":86,"address":[3095897,3095979,3095997,3095377,3095422,3095587],"length":1,"stats":{"Line":0}},{"line":88,"address":[3095454,3095395],"length":1,"stats":{"Line":0}},{"line":98,"address":[3095357],"length":1,"stats":{"Line":0}},{"line":101,"address":[3096982,3096000,3096988],"length":1,"stats":{"Line":0}},{"line":106,"address":[3096046],"length":1,"stats":{"Line":0}},{"line":109,"address":[3096137,3096077],"length":1,"stats":{"Line":0}},{"line":110,"address":[3096167],"length":1,"stats":{"Line":0}},{"line":118,"address":[3096263,3096148],"length":1,"stats":{"Line":0}},{"line":119,"address":[3096376,3096649],"length":1,"stats":{"Line":0}},{"line":120,"address":[3096888],"length":1,"stats":{"Line":0}},{"line":121,"address":[3096682],"length":1,"stats":{"Line":0}},{"line":128,"address":[3096409,3096604],"length":1,"stats":{"Line":0}},{"line":129,"address":[3096564,3096495],"length":1,"stats":{"Line":0}},{"line":131,"address":[3096507,3096430],"length":1,"stats":{"Line":0}},{"line":137,"address":[3097024],"length":1,"stats":{"Line":0}},{"line":138,"address":[3097045],"length":1,"stats":{"Line":0}},{"line":148,"address":[3097072],"length":1,"stats":{"Line":0}},{"line":149,"address":[3097080],"length":1,"stats":{"Line":0}},{"line":154,"address":[3097104],"length":1,"stats":{"Line":0}},{"line":155,"address":[3097117],"length":1,"stats":{"Line":0}},{"line":158,"address":[3097313,3097168],"length":1,"stats":{"Line":0}},{"line":159,"address":[3097229],"length":1,"stats":{"Line":0}},{"line":160,"address":[3097286],"length":1,"stats":{"Line":0}},{"line":165,"address":[3097344,3098370,3098437],"length":1,"stats":{"Line":0}},{"line":166,"address":[3097387],"length":1,"stats":{"Line":0}},{"line":167,"address":[3097418],"length":1,"stats":{"Line":0}},{"line":168,"address":[3097467],"length":1,"stats":{"Line":0}},{"line":170,"address":[3097472,3097533,3098335],"length":1,"stats":{"Line":0}},{"line":171,"address":[3097623,3097910],"length":1,"stats":{"Line":0}},{"line":172,"address":[3098136],"length":1,"stats":{"Line":0}},{"line":173,"address":[3098146],"length":1,"stats":{"Line":0}},{"line":175,"address":[3098151],"length":1,"stats":{"Line":0}},{"line":176,"address":[3098252],"length":1,"stats":{"Line":0}},{"line":179,"address":[3097736],"length":1,"stats":{"Line":0}},{"line":180,"address":[3097654],"length":1,"stats":{"Line":0}},{"line":181,"address":[3097658],"length":1,"stats":{"Line":0}},{"line":182,"address":[3097697],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":58}],"coverage":10.99476439790576,"covered":21,"coverable":191}